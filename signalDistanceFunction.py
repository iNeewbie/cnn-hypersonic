# -*- coding: utf-8 -*-
"""SDF.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LtIiSdYAC4Fka-jFo93hIbpyuM1llv-L
"""

#!pip install scikit-fmm
#!pip install airfoils
#!pip install --upgrade airfoils
#!pip install meshio[all]


import pandas as pd
from numpy.ma.core import ones_like
import numpy as np
import pylab as plt
import skfmm
import matplotlib.pyplot as plt
plt.close('all')

np.set_printoptions(threshold=np.inf)

data = np.genfromtxt('dw5.dat',
                     delimiter='',
                     skip_header=0)



# Define the angle of attack in degrees
angle_of_attack = 5

# Convert the angle to radians
angle_rad = np.radians(-angle_of_attack)

# Create the rotation matrix
rotation_matrix = np.array([[np.cos(angle_rad), -np.sin(angle_rad)],
                            [np.sin(angle_rad), np.cos(angle_rad)]])

# Define the grid for the signed distance function calculation
nx, ny = 150, 150
x = np.linspace(-0.5, 1.5, nx)
y = np.linspace(-0.5, 0.5, ny)
X, Y = np.meshgrid(x, y)
def create_airfoil_mask(x_coords, y_coords, X, Y):
    from matplotlib.path import Path

    airfoil_path = Path(list(zip(x_coords, y_coords)))
    mask = airfoil_path.contains_points(np.vstack([X.ravel(), Y.ravel()]).T).reshape(X.shape)

    return mask

# Replace these with your airfoil coordinates
x_coords = np.array(data[:,0])
y_coords = np.array(data[:,1])

#Subtract the leading edge coordinates to center the airfoil at the origin
x_coords_centered = x_coords - x_coords[0]
y_coords_centered = y_coords - y_coords[0]

# Apply the rotation matrix to the centered coordinates
rotated_coords = rotation_matrix @ np.array([x_coords_centered, y_coords_centered])

# Add the leading edge coordinates back to shift the airfoil back to its original position
x_coords_rotated = rotated_coords[0] + x_coords[0]
y_coords_rotated = rotated_coords[1] + y_coords[0]

# Now you can use x_coords_rotated and y_coords_rotated in your code
airfoil_mask = create_airfoil_mask(x_coords_rotated, y_coords_rotated, X, Y)

#airfoil_mask = create_airfoil_mask(x_coords, y_coords, X, Y)
# Create the initial distance field
phi = np.where(airfoil_mask, -1, 1)

# Compute the signed distance function using the Fast Marching Method
distance = skfmm.distance(phi,dx=0.001)

# Plot the signed distance function
plt.figure()
plt.contourf(X, Y, distance, levels=9)
plt.colorbar(label='Signed Distance')
plt.plot(x_coords_rotated, y_coords_rotated, 'k-', linewidth=0.5)
plt.axis('equal')
plt.xlim([-0.5,1.5])
plt.ylim([-0.5,0.5])
plt.show()

import meshio

mesh = meshio.read('a.msh')

points, cells, cells_dict = mesh.points, mesh.cells, mesh.cells_dict

print(points.shape)
plt.figure()
plt.plot(points[:,0],points[:,1],'ko',markersize=1)
plt.plot(X,Y,'r-',linewidth=0.7)
plt.axis('equal')

plt.xlim([-0.5,0.5])
plt.ylim([-0.5,0.5])
plt.show()

# Plot the grid
plt.figure(figsize=(6,6))
plt.grid(color='gray', linestyle='-', linewidth=0.5)
plt.scatter(X, Y, s=1, color='black')
plt.xlim([-1, 1])
plt.ylim([-1, 1])
plt.gca().set_aspect('equal', adjustable='box')
plt.show()


data = np.genfromtxt('DataCFD/FFF-27-00500',
                     delimiter=',',
                     skip_header=1)
